<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<script type="text/javascript">
			//1.冒泡排序
			//冒泡排序算法的原理如下：
			//比较相邻的元素。如果第一个比第二个大，就交换他们两个。
			//对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
			//针对所有的元素重复以上的步骤，除了最后一个。
			//持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
			/*var arr=[9,30,4,89,75,456,2,7,-100,9];
			var times=0;//次数
			for(var i=0;i<arr.length-1;i++){//控制次数  -1:10个数字只需要两两比较9次。
				for(var j=0;j<arr.length-i-1;j++){//-i:i循环一次，j循环到底，每一次i的循环都已经排好一个数字。
					if(arr[j]>arr[j+1]){
						var temp=arr[j];
						arr[j]=arr[j+1];
						arr[j+1]=temp;
					}
					times++;
				}
			}
			console.log(arr);
			console.log(times);*/
			
			
			//2.选择排序
			//选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。
			/*var arr=[9,300,4,890,7500,456,20,70,-100,-9];
			for(var i=0;i<arr.length;i++){
				var minindex=i;//假设最小值的下标
				var minvalue=arr[minindex];//假设最小值
				
				for(var j=i+1; j<arr.length;j++){
					if(minvalue>arr[j]){
						minvalue=arr[j];
						minindex=j;
					}
				}
				//如果上面的for循环完成，代表minindex就是最小值的下标。
				if(minindex!=i){//如果minindex!=i说明找到了真正的最小值。否则就代表假设的刚好就是最小值。
					var temp=arr[minindex]
					arr[minindex]=arr[i];
					arr[i]=temp;
				}
			}
			console.log(arr);*/
			var arr=[9,300,4,890,7500,456,20,70,-100,-9,90];
			function quick(arr){	    		
	                if(arr.length==0)
	                   {return arr;}
	                else
	                {
		                var midindex=parseInt(arr.length/2);//获取中间值得索引
			    		var midvalue=arr.splice(midindex,1)[0];//获取中间值
			    		var left=[];
			    		var right=[];
			    		for(var i=0;i<arr.length;i++)
			    		{
			    			if(arr[i]<midvalue)
			    			  {left.push(arr[i]);}
			    			else
			    			  {right.push(arr[i]);}		    					    			
			    		}
			    		return quick(left).concat(midvalue,quick(right));//递归	    				    		
	                }	    		
		    	}
		    	console.log(quick(arr));
			
		</script>
	</body>
</html>
